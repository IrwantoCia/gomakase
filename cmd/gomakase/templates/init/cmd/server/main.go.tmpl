package main

import (
	authApp "{{.ProjectName}}/internal/auth_context/application"
	authDelivery "{{.ProjectName}}/internal/auth_context/delivery"
	authInfra "{{.ProjectName}}/internal/auth_context/infrastructure"
	"{{.ProjectName}}/internal/shared/config"
	"{{.ProjectName}}/internal/shared/db"
	"{{.ProjectName}}/internal/shared/logger"
	"{{.ProjectName}}/internal/shared/middleware"
	userApp "{{.ProjectName}}/internal/user_context/application"
	userInfra "{{.ProjectName}}/internal/user_context/infrastructure"
	"context"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/foolin/goview"
	"github.com/foolin/goview/supports/ginview"
	"github.com/gin-gonic/gin"
)

func main() {
	// --- 1. Instantiate the Shared Logger ---
	appConfig, err := config.Load("")
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}
	appLogger := logger.NewLogger(appConfig.LogLevel)
	defer appLogger.Sync()

	if appConfig.LogLevel != "debug" {
		gin.SetMode(gin.ReleaseMode)
	}

	database, err := db.ConnectToDatabase(appConfig.Database, appLogger)
	if err != nil {
		appLogger.Fatal("Failed to connect to the database: %v", err)
	}
	defer database.CloseDatabase()

	database.AutoMigrateSchemas(&authInfra.AuthSchema{}, &userInfra.UserSchema{})

	// --- 2. Router Setup ---
	router := gin.New()

	// --- 3. Middleware Setup ---
	router.HTMLRender = ginview.New(goview.Config{
		Root:         "web/views",
		Extension:    ".html",
		Master:       "layouts/master",
		Partials:     []string{},
		Funcs:        template.FuncMap{},
		DisableCache: true,
	})

	router.Use(middleware.Logger(appLogger))
	router.Use(gin.Recovery())

	router.Static("/static", "web/static")

	// --- 4. Wiring the Context ---
	authRepository := authInfra.NewAuthRepositoryImpl(database.DB, appLogger)
	userRepository := userInfra.NewUserRepositoryImpl(database.DB, appLogger)

	userAPIService := userApp.NewUserAPIService(userRepository)
	authService := authApp.NewAuthService(appLogger, authRepository, appConfig.JWT, userAPIService)

	authHandler := authDelivery.NewAuthHandler(appLogger, authService)

	// Landing page
	router.GET("/", func(c *gin.Context) {
		c.HTML(http.StatusOK, "index.html", gin.H{"title": "Home"})
	})
	router.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status": "UP",
		})
	})

	// Main Routes
	router.GET("/register", authHandler.RegisterPage)
	router.POST("/register", authHandler.Register)

	router.GET("/login", authHandler.LoginPage)
	router.POST("/login", authHandler.Login)

	protectedRoutes := router.Group("/")
	protectedRoutes.Use(middleware.AuthMiddleware(authService, userAPIService))
	protectedRoutes.DELETE("/logout", authHandler.Logout)

	// --- 5. Server Setup ---
	appLogger.Info("Starting server on port: ", "port", appConfig.Server.Port)
	server := &http.Server{
		Addr:    fmt.Sprintf(":%d", appConfig.Server.Port),
		Handler: router,
	}

	go func() {
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			appLogger.Fatal("listen: %s\n", err)
		}
	}()

	// Graceful shutdown
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	appLogger.Info("Shutdown Server ...")

	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()
	if err := server.Shutdown(ctx); err != nil {
		appLogger.Fatal("Server forced to shutdown:", err)
	}
	<-ctx.Done()
	appLogger.Info("Server exiting")
}
